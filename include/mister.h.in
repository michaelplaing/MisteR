/*============================================================================*
 * mister: MQTT protocol for Redis.
 * Copyright (C) 2021  Michael P. Laing

 * This file is part of mister.

 * mister is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * mister is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with libbsat.  If not, see <https://www.gnu.org/licenses/>.
 *----------------------------------------------------------------------------*/

#ifndef MISTER_H
#define MISTER_H

#include <sys/types.h>
#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include <Judy.h>

#ifdef __cplusplus
//extern "C" {
#endif /* __cplusplus */

#define PROTOCOL_NAME "MQTT"
#define PROTOCOL_VERSION_v5 5

/* Message types */
#define CMD_CONNECT 0x10U
#define CMD_CONNACK 0x20U
#define CMD_PUBLISH 0x30U
#define CMD_PUBACK 0x40U
#define CMD_PUBREC 0x50U
#define CMD_PUBREL 0x60U
#define CMD_PUBCOMP 0x70U
#define CMD_SUBSCRIBE 0x80U
#define CMD_SUBACK 0x90U
#define CMD_UNSUBSCRIBE 0xA0U
#define CMD_UNSUBACK 0xB0U
#define CMD_PINGREQ 0xC0U
#define CMD_PINGRESP 0xD0U
#define CMD_DISCONNECT 0xE0U
#define CMD_AUTH 0xF0U

/* MisteR Commands understood by the Redis module mister.so */
#define MR_CONNECT       "mr.connect"
#define MR_CONNACK       "mr.connack"
#define MR_PUBLISH	     "mr.publish"
#define MR_PUBACK        "mr.puback"
#define MR_PUBREC        "mr.pubrec"
#define MR_PUBREL        "mr.pubrel"
#define MR_PUBCOMP       "mr.pubcomp"
#define MR_SUBSCRIBE     "mr.subscribe"
#define MR_SUBACK        "mr.suback"
#define MR_UNSUBSCRIBE   "mr.unsubscribe"
#define MR_UNSUBACK      "mr.unsuback"
#define MR_PINGREQ       "mr.pingreq"
#define MR_PINGRESP      "mr.pingresp"
#define MR_DISCONNECT    "mr.disconnect"
#define MR_AUTH          "mr.auth"

typedef struct pack_ctx {
    uint8_t *buf;
    size_t pos;
    size_t propcnt;
    size_t len;
} pack_ctx;

struct connect_hv;

typedef struct connect_hv {
    char *name;
    int (*pack_fn)(pack_ctx *pctx, struct connect_hv *chv);
    Word_t value; /* can handle each header_var value including pointers */
    size_t bitpos; // for sub-byte values
    bool exists; // for properties
    uint8_t id; // for properties
    size_t len; // for pointer values & VBIs
} connect_hv;

int pack_uint8(pack_ctx *pctx, connect_hv *chv){
    pctx->buf[pctx->pos] = chv->value;
    pctx->pos++;
    return 0;
}

int pack_uint16(pack_ctx *pctx, connect_hv *chv){
    uint16_t val16 = chv->value;
    pctx->buf[pctx->pos] = (val16 >> 8) & 0xFF;
    pctx->buf[pctx->pos + 1] = val16 & 0xFF;
    pctx->pos += 2;
    return 0;
}

int pack_uint32(pack_ctx *pctx, connect_hv *chv){
    uint32_t val32 = chv->value;
    pctx->buf[pctx->pos] = (val32 >> 24) & 0xFF;
    pctx->buf[pctx->pos + 1] = (val32 >> 16) & 0xFF;
    pctx->buf[pctx->pos + 2] = (val32 >> 8) & 0xFF;
    pctx->buf[pctx->pos + 3] = val32 & 0xFF;
    pctx->pos += 4;
    return 0;
}

int pack_prop_uint32(pack_ctx *pctx, connect_hv *chv) {
    if (chv->exists) {
        uint32_t tempvalue = chv->value;
        chv->value = chv->id;
        pack_uint8(pctx, chv);
        chv->value = tempvalue;
        pack_uint32(pctx, chv);
    }

    return 0;
}

int pack_VBI(pack_ctx *pctx, connect_hv *chv) { // assume 1 byte for now
    pctx->buf[pctx->pos] = chv->value;
    pctx->pos++;
    return 0;
}

int pack_buffer(pack_ctx *pctx, connect_hv *chv){
    memcpy(pctx->buf + pctx->pos, (uint8_t *)(chv->value), chv->len);
    pctx->pos += chv->len;
    return 0;
}

const uint8_t single_bit = 0x01;
const uint8_t two_bits = 0x03;

int pack_bool_in_uint8(pack_ctx *pctx, connect_hv *chv){
    if (chv->value) {
        pctx->buf[pctx->pos] = (pctx->buf[pctx->pos] | (single_bit << chv->bitpos));
    } else {
        pctx->buf[pctx->pos] = (pctx->buf[pctx->pos] & ~(single_bit << chv->bitpos));
    }

    if (chv->bitpos == 7) pctx->pos++;
    return 0;
}

int pack_uint8_in_uint8(pack_ctx *pctx, connect_hv *chv){
    pctx->buf[pctx->pos] = (pctx->buf[pctx->pos] & ~(two_bits << chv->bitpos));

    if (chv->value) {
        uint8_t val = chv->value;
        pctx->buf[pctx->pos] = (pctx->buf[pctx->pos] | (val << chv->bitpos));
    }

    return 0;
}

const uint8_t protocol_name[] = {0x00, 0x04, 'M', 'Q', 'T', 'T'};

connect_hv connect_hvs[] = { // name, function, value, bitpos, exists, id, len
    {"packet_type", pack_uint8, CMD_CONNECT, 0},
    {"remaining_length", pack_VBI, 0},
    {"protocol_name", pack_buffer, (Word_t)protocol_name, 0, 0, 0, sizeof(protocol_name)},
    {"protocol_version", pack_uint8, 5, 0},
    {"reserved", pack_bool_in_uint8, false, 0, 0},
    {"clean_start", pack_bool_in_uint8, false, 1, 0},
    {"will_flag", pack_bool_in_uint8, false, 2, 0},
    {"will_qos", pack_uint8_in_uint8, 0, 3, 0},
    {"will_retain", pack_bool_in_uint8, false, 5, 0},
    {"password_flag", pack_bool_in_uint8, false, 6, 0},
    {"username_flag", pack_bool_in_uint8, false, 7, 0},
    {"keep_alive", pack_uint16, 0},
    {"property_length", pack_VBI, 0},
    {"session_expiry", pack_prop_uint32, 0, 0, false, 0x11, 0}

/*
    uint8_t session_expiry_id;
    uint32_t session_expiry;
    uint8_t receive_maximum_id;
    uint16_t receive_maximum;
    uint8_t maximum_packet_size_id;
    uint32_t maximum_packet_size;
    uint8_t topic_alias_maximum_id;
    uint16_t topic_alias_maximum;
    uint8_t request_response_information_id;
    uint8_t request_response_information;
    uint8_t request_problem_information_id;
    uint8_t request_problem_information;
    uint8_t user_property_id;
    uint8_t *user_properties;
    uint8_t authentication_method_id;
    uint8_t *authentication_method;
    uint8_t authentication_data_id;
    uint8_t *authentication_data;
*/
};

typedef struct connect_header_vars {
    uint8_t packet_type;
    uint32_t remaining_length; /* encode as Variable Byte Integer (VBI) */
    uint8_t protocol_name[6];
    uint8_t protocol_version;
    bool reserved;
    bool clean_start;
    bool will_flag;
    uint8_t will_qos;
    bool will_retain;
    bool password_flag;
    bool username_flag;
    uint16_t keep_alive;
    /* properties - each optionally present */
    uint32_t property_length; /* encode as a VBI tho for MQTT 5 it is always a single byte */
    uint8_t session_expiry_id;
    uint32_t session_expiry;
    uint8_t receive_maximum_id;
    uint16_t receive_maximum;
    uint8_t maximum_packet_size_id;
    uint32_t maximum_packet_size;
    uint8_t topic_alias_maximum_id;
    uint16_t topic_alias_maximum;
    uint8_t request_response_information_id;
    uint8_t request_response_information;
    uint8_t request_problem_information_id;
    uint8_t request_problem_information;
    uint8_t user_property_id; /* prefix each String Pair below with this id when building packet */
    uint8_t *user_properties; /* pointer to catenated MQTT UTF-8 String Pairs if any */
    uint8_t authentication_method_id; /* 0x15 */
    uint8_t *authentication_method; /* pointer to a UTF-8 Encoded String with the authentication method if any */
    uint8_t authentication_data_id; /* 0x16 */
    uint8_t *authentication_data; /* pointer to Binary Data containing authentication data if any*/
} connect_header_vars;

const connect_header_vars connect_header_vars_template = {
    .packet_type = CMD_CONNECT,
    .remaining_length = 0,
    .protocol_name = {0x00, 0x04, 'M', 'Q', 'T', 'T'},
    .protocol_version = 5,
    .reserved = false,
    .clean_start = false,
    .will_flag = false,
    .will_qos = 0,
    .will_retain = false,
    .password_flag = false,
    .username_flag = false,
    .keep_alive = 0,
    /* properties - 0 for an id indicates the property should not be present in the packet */
    .property_length = 0,
    .session_expiry_id = 0, /* 0x11 */
    .session_expiry = 0,
    .receive_maximum_id = 0, /* 0x33 */
    .receive_maximum = 0,
    .maximum_packet_size_id = 0, /* 0x39 */
    .maximum_packet_size = 0,
    .topic_alias_maximum_id = 0, /* 0x22 */
    .topic_alias_maximum = 0,
    .request_response_information_id = 0, /* 0x19 */
    .request_response_information = 0,
    .request_problem_information_id = 0, /* 0x17 */
    .request_problem_information = 0,
    .user_property_id = 0, /* 0x26 */
    .user_properties = NULL,
    .authentication_method_id = 0, /* 0x15 */
    .authentication_method = NULL,
    .authentication_data_id = 0, /* 0x16 */
    .authentication_data = NULL
};

struct mrpacket{
    uint8_t *payload;
    uint32_t len;
    uint32_t pos;
};

/* Error values */
enum mrerr_t {
    MRERR_AUTH_CONTINUE = -4,
    MRERR_NO_SUBSCRIBERS = -3,
    MRERR_SUB_EXISTS = -2,
    MRERR_CONN_PENDING = -1,
    MRERR_SUCCESS = 0,
    MRERR_NOMEM = 1,
    MRERR_PROTOCOL = 2,
    MRERR_INVAL = 3,
    MRERR_NO_CONN = 4,
    MRERR_CONN_REFUSED = 5,
    MRERR_NOT_FOUND = 6,
    MRERR_CONN_LOST = 7,
    MRERR_TLS = 8,
    MRERR_PAYLOAD_SIZE = 9,
    MRERR_NOT_SUPPORTED = 10,
    MRERR_AUTH = 11,
    MRERR_ACL_DENIED = 12,
    MRERR_UNKNOWN = 13,
    MRERR_ERRNO = 14,
    MRERR_EAI = 15,
    MRERR_PROXY = 16,
    MRERR_PLUGIN_DEFER = 17,
    MRERR_MALFORMED_UTF8 = 18,
    MRERR_KEEPALIVE = 19,
    MRERR_LOOKUP = 20,
    MRERR_MALFORMED_PACKET = 21,
    MRERR_DUPLICATE_PROPERTY = 22,
    MRERR_TLS_HANDSHAKE = 23,
    MRERR_QOS_NOT_SUPPORTED = 24,
    MRERR_OVERSIZE_PACKET = 25,
    MRERR_OCSP = 26,
    MRERR_TIMEOUT = 27,
    MRERR_RETAIN_NOT_SUPPORTED = 28,
    MRERR_TOPIC_ALIAS_INVALID = 29,
    MRERR_ADMINISTRATIVE_ACTION = 30,
    MRERR_ALREADY_EXISTS = 31,
};


#define PROTOCOL_NAME "MQTT"
#define PROTOCOL_VERSION_v5 5

/* Message types */
#define CMD_CONNECT 0x10U
#define CMD_CONNACK 0x20U
#define CMD_PUBLISH 0x30U
#define CMD_PUBACK 0x40U
#define CMD_PUBREC 0x50U
#define CMD_PUBREL 0x60U
#define CMD_PUBCOMP 0x70U
#define CMD_SUBSCRIBE 0x80U
#define CMD_SUBACK 0x90U
#define CMD_UNSUBSCRIBE 0xA0U
#define CMD_UNSUBACK 0xB0U
#define CMD_PINGREQ 0xC0U
#define CMD_PINGRESP 0xD0U
#define CMD_DISCONNECT 0xE0U
#define CMD_AUTH 0xF0U

enum mqtt5_return_codes {
    MQTT_RC_SUCCESS = 0,						/* CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, UNSUBACK, AUTH */
    MQTT_RC_NORMAL_DISCONNECTION = 0,			/* DISCONNECT */
    MQTT_RC_GRANTED_QOS0 = 0,					/* SUBACK */
    MQTT_RC_GRANTED_QOS1 = 1,					/* SUBACK */
    MQTT_RC_GRANTED_QOS2 = 2,					/* SUBACK */
    MQTT_RC_DISCONNECT_WITH_WILL_MSG = 4,		/* DISCONNECT */
    MQTT_RC_NO_MATCHING_SUBSCRIBERS = 16,		/* PUBACK, PUBREC */
    MQTT_RC_NO_SUBSCRIPTION_EXISTED = 17,		/* UNSUBACK */
    MQTT_RC_CONTINUE_AUTHENTICATION = 24,		/* AUTH */
    MQTT_RC_REAUTHENTICATE = 25,				/* AUTH */

    MQTT_RC_UNSPECIFIED = 128,					/* CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT */
    MQTT_RC_MALFORMED_PACKET = 129,				/* CONNACK, DISCONNECT */
    MQTT_RC_PROTOCOL_ERROR = 130,				/* DISCONNECT */
    MQTT_RC_IMPLEMENTATION_SPECIFIC = 131,		/* CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT */
    MQTT_RC_UNSUPPORTED_PROTOCOL_VERSION = 132,	/* CONNACK */
    MQTT_RC_CLIENTID_NOT_VALID = 133,			/* CONNACK */
    MQTT_RC_BAD_USERNAME_OR_PASSWORD = 134,		/* CONNACK */
    MQTT_RC_NOT_AUTHORIZED = 135,				/* CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT */
    MQTT_RC_SERVER_UNAVAILABLE = 136,			/* CONNACK */
    MQTT_RC_SERVER_BUSY = 137,					/* CONNACK, DISCONNECT */
    MQTT_RC_BANNED = 138,						/* CONNACK */
    MQTT_RC_SERVER_SHUTTING_DOWN = 139,			/* DISCONNECT */
    MQTT_RC_BAD_AUTHENTICATION_METHOD = 140,	/* CONNACK */
    MQTT_RC_KEEP_ALIVE_TIMEOUT = 141,			/* DISCONNECT */
    MQTT_RC_SESSION_TAKEN_OVER = 142,			/* DISCONNECT */
    MQTT_RC_TOPIC_FILTER_INVALID = 143,			/* SUBACK, UNSUBACK, DISCONNECT */
    MQTT_RC_TOPIC_NAME_INVALID = 144,			/* CONNACK, PUBACK, PUBREC, DISCONNECT */
    MQTT_RC_PACKET_ID_IN_USE = 145,				/* PUBACK, SUBACK, UNSUBACK */
    MQTT_RC_PACKET_ID_NOT_FOUND = 146,			/* PUBREL, PUBCOMP */
    MQTT_RC_RECEIVE_MAXIMUM_EXCEEDED = 147,		/* DISCONNECT */
    MQTT_RC_TOPIC_ALIAS_INVALID = 148,			/* DISCONNECT */
    MQTT_RC_PACKET_TOO_LARGE = 149,				/* CONNACK, PUBACK, PUBREC, DISCONNECT */
    MQTT_RC_MESSAGE_RATE_TOO_HIGH = 150,		/* DISCONNECT */
    MQTT_RC_QUOTA_EXCEEDED = 151,				/* PUBACK, PUBREC, SUBACK, DISCONNECT */
    MQTT_RC_ADMINISTRATIVE_ACTION = 152,		/* DISCONNECT */
    MQTT_RC_PAYLOAD_FORMAT_INVALID = 153,		/* CONNACK, DISCONNECT */
    MQTT_RC_RETAIN_NOT_SUPPORTED = 154,			/* CONNACK, DISCONNECT */
    MQTT_RC_QOS_NOT_SUPPORTED = 155,			/* CONNACK, DISCONNECT */
    MQTT_RC_USE_ANOTHER_SERVER = 156,			/* CONNACK, DISCONNECT */
    MQTT_RC_SERVER_MOVED = 157,					/* CONNACK, DISCONNECT */
    MQTT_RC_SHARED_SUBS_NOT_SUPPORTED = 158,	/* SUBACK, DISCONNECT */
    MQTT_RC_CONNECTION_RATE_EXCEEDED = 159,		/* CONNACK, DISCONNECT */
    MQTT_RC_MAXIMUM_CONNECT_TIME = 160,			/* DISCONNECT */
    MQTT_RC_SUBSCRIPTION_IDS_NOT_SUPPORTED = 161, /* SUBACK, DISCONNECT */
    MQTT_RC_WILDCARD_SUBS_NOT_SUPPORTED = 162,	/* SUBACK, DISCONNECT */
};

enum mqtt5_property {
    MQTT_PROP_PAYLOAD_FORMAT_INDICATOR = 1,		/* Byte :				PUBLISH, Will Properties */
    MQTT_PROP_MESSAGE_EXPIRY_INTERVAL = 2,		/* 4 byte int :			PUBLISH, Will Properties */
    MQTT_PROP_CONTENT_TYPE = 3,					/* UTF-8 string :		PUBLISH, Will Properties */
    MQTT_PROP_RESPONSE_TOPIC = 8,				/* UTF-8 string :		PUBLISH, Will Properties */
    MQTT_PROP_CORRELATION_DATA = 9,				/* Binary Data :		PUBLISH, Will Properties */
    MQTT_PROP_SUBSCRIPTION_IDENTIFIER = 11,		/* Variable byte int :	PUBLISH, SUBSCRIBE */
    MQTT_PROP_SESSION_EXPIRY_INTERVAL = 17,		/* 4 byte int :			CONNECT, CONNACK, DISCONNECT */
    MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER = 18,	/* UTF-8 string :		CONNACK */
    MQTT_PROP_SERVER_KEEP_ALIVE = 19,			/* 2 byte int :			CONNACK */
    MQTT_PROP_AUTHENTICATION_METHOD = 21,		/* UTF-8 string :		CONNECT, CONNACK, AUTH */
    MQTT_PROP_AUTHENTICATION_DATA = 22,			/* Binary Data :		CONNECT, CONNACK, AUTH */
    MQTT_PROP_REQUEST_PROBLEM_INFORMATION = 23,	/* Byte :				CONNECT */
    MQTT_PROP_WILL_DELAY_INTERVAL = 24,			/* 4 byte int :			Will properties */
    MQTT_PROP_REQUEST_RESPONSE_INFORMATION = 25,/* Byte :				CONNECT */
    MQTT_PROP_RESPONSE_INFORMATION = 26,		/* UTF-8 string :		CONNACK */
    MQTT_PROP_SERVER_REFERENCE = 28,			/* UTF-8 string :		CONNACK, DISCONNECT */
    MQTT_PROP_REASON_STRING = 31,				/* UTF-8 string :		All except Will properties */
    MQTT_PROP_RECEIVE_MAXIMUM = 33,				/* 2 byte int :			CONNECT, CONNACK */
    MQTT_PROP_TOPIC_ALIAS_MAXIMUM = 34,			/* 2 byte int :			CONNECT, CONNACK */
    MQTT_PROP_TOPIC_ALIAS = 35,					/* 2 byte int :			PUBLISH */
    MQTT_PROP_MAXIMUM_QOS = 36,					/* Byte :				CONNACK */
    MQTT_PROP_RETAIN_AVAILABLE = 37,			/* Byte :				CONNACK */
    MQTT_PROP_USER_PROPERTY = 38,				/* UTF-8 string pair :	All */
    MQTT_PROP_MAXIMUM_PACKET_SIZE = 39,			/* 4 byte int :			CONNECT, CONNACK */
    MQTT_PROP_WILDCARD_SUB_AVAILABLE = 40,		/* Byte :				CONNACK */
    MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE = 41,	/* Byte :				CONNACK */
    MQTT_PROP_SHARED_SUB_AVAILABLE = 42,		/* Byte :				CONNACK */
};

enum mqtt5_property_type {
    MQTT_PROP_TYPE_BYTE = 1,
    MQTT_PROP_TYPE_INT16 = 2,
    MQTT_PROP_TYPE_INT32 = 3,
    MQTT_PROP_TYPE_VARINT = 4,
    MQTT_PROP_TYPE_BINARY = 5,
    MQTT_PROP_TYPE_STRING = 6,
    MQTT_PROP_TYPE_STRING_PAIR = 7
};

/* Enum: mqtt5_sub_options
 * Options for use with MQTTv5 subscriptions.
 *
 * MQTT_SUB_OPT_NO_LOCAL - with this option set, if this client publishes to
 * a topic to which it is subscribed, the broker will not publish the
 * message back to the client.
 *
 * MQTT_SUB_OPT_RETAIN_AS_PUBLISHED - with this option set, messages
 * published for this subscription will keep the retain flag as was set by
 * the publishing client. The default behaviour without this option set has
 * the retain flag indicating whether a message is fresh/stale.
 *
 * MQTT_SUB_OPT_SEND_RETAIN_ALWAYS - with this option set, pre-existing
 * retained messages are sent as soon as the subscription is made, even
 * if the subscription already exists. This is the default behaviour, so
 * it is not necessary to set this option.
 *
 * MQTT_SUB_OPT_SEND_RETAIN_NEW - with this option set, pre-existing retained
 * messages for this subscription will be sent when the subscription is made,
 * but only if the subscription does not already exist.
 *
 * MQTT_SUB_OPT_SEND_RETAIN_NEVER - with this option set, pre-existing
 * retained messages will never be sent for this subscription.
 */
enum mqtt5_sub_options {
    MQTT_SUB_OPT_NO_LOCAL = 0x04,
    MQTT_SUB_OPT_RETAIN_AS_PUBLISHED = 0x08,
    MQTT_SUB_OPT_SEND_RETAIN_ALWAYS = 0x00,
    MQTT_SUB_OPT_SEND_RETAIN_NEW = 0x10,
    MQTT_SUB_OPT_SEND_RETAIN_NEVER = 0x20,
};

#define MQTT_MAX_PAYLOAD 268435455U

#ifdef __cpluplus
//}
#endif /* __cplusplus */

#endif /* MISTER_H */
